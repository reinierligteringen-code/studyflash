<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Study Cards — Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <style>
    :root{
      --brand:#0a84ff;
      --ink:#111;
      --ink-2:#444;
      --bg:#f7f7fb;
      --panel:#ffffff;
      --line:#e7e7ee;
      --accent:#0a84ff;
      --ok:#0ea5e9;
      --warn:#ef4444;

      --toolbar-h:56px;
      --sidebar-w:420px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

    .header{
      position:sticky; top:0; z-index:100;
      height:56px; display:flex; align-items:center; gap:12px;
      padding:10px 14px; background:var(--panel); border-bottom:1px solid var(--line);
    }
    .header a.back{
      text-decoration:none; color:var(--ink-2);
      padding:6px 10px; border:1px solid var(--line); border-radius:10px;
    }
    .header .title{font-weight:600}

    .wrap{
      height:calc(100vh - 56px);
      display:grid; grid-template-columns: var(--sidebar-w) 1fr;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr; height:auto}
      .canvasPane{height:70vh}
    }

    /* Sidebar / Form */
    .sidebar{
      overflow:auto; background:var(--panel); border-right:1px solid var(--line);
      padding:16px 16px 100px;
    }
    .section{margin-bottom:18px}
    .section h3{margin:0 0 10px 0; font-size:15px}
    label{display:block; font-size:12px; color:var(--ink-2); margin:10px 0 6px}
    input[type="text"], textarea{
      width:100%; border:1px solid var(--line); border-radius:12px; padding:10px 12px;
      background:#fff; color:var(--ink); resize:vertical;
    }
    textarea{min-height:84px}
    .preview{
      border:1px dashed var(--line); background:#fff; border-radius:12px; padding:12px; min-height:72px;
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .muted{color:var(--ink-2); font-size:12px}

    /* Buttons */
    button{
      border:1px solid var(--line); background:#fff; padding:9px 12px; border-radius:12px;
      cursor:pointer; user-select:none;
    }
    button.primary{border-color:var(--accent); background:var(--accent); color:#fff}
    button.ghost{background:#fff}
    button.active{border-color:var(--accent); box-shadow:0 0 0 2px rgba(10,132,255,.15)}
    button:disabled{opacity:.6; cursor:not-allowed}

    /* Canvas side */
    .canvasPane{
      position:relative; background:#fff;
      height:100%; /* full height when in two-column */
    }
    .toolbar{
      height:var(--toolbar-h);
      display:flex; gap:10px; align-items:center;
      padding:10px 12px; background:#fff; border-bottom:1px solid var(--line);
      position:sticky; top:0; z-index:10;
    }
    .toolbar .group{display:flex; gap:6px; align-items:center}
    input[type="range"]{width:140px}
    .spacer{flex:1}
    .pad{position:relative; width:100%; height:calc(100% - var(--toolbar-h)); touch-action:none; background:#fff}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block}

    .tag{
      display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid var(--line);
      background:#fff; font-size:12px; margin-right:6px; margin-top:6px;
    }
  </style>
</head>

<body>
  <div class="header">
    <a class="back" href="./index.html" title="Back to Home">← Home</a>
    <div class="title">Edit Flashcard</div>
    <div class="spacer"></div>
    <div class="muted">LaTeX supported: <code>$...$</code> or <code>$$...$$</code></div>
  </div>

  <div class="wrap">
    <!-- LEFT: Card form + live preview -->
    <aside class="sidebar">
      <div class="section">
        <label for="title">Title</label>
        <input id="title" type="text" placeholder="e.g. Week 2 — MRS and Budget Line">
      </div>

      <div class="section">
        <h3>Front (Question)</h3>
        <label for="frontInput">Text (LaTeX allowed)</label>
        <textarea id="frontInput" placeholder="Type the question… e.g. Show that the MRS equals the price ratio at the interior optimum. Use $U(x,y)=x^\alpha y^{1-\alpha}$."></textarea>
        <div class="row muted">
          <span>Preview</span>
          <span class="tag">Rendered</span>
        </div>
        <div id="frontPreview" class="preview"></div>
      </div>

      <div class="section">
        <h3>Back (Answer)</h3>
        <label for="backInput">Text (LaTeX allowed)</label>
        <textarea id="backInput" placeholder="Sketch the steps and result… e.g. $$MRS=\frac{MU_x}{MU_y}=\frac{p_x}{p_y}$$"></textarea>
        <div class="row muted">
          <span>Preview</span>
          <span class="tag">Rendered</span>
        </div>
        <div id="backPreview" class="preview"></div>
      </div>

      <div class="section">
        <h3>Attach drawing to…</h3>
        <div class="row">
          <label class="tag"><input type="radio" name="attachTo" value="front" checked> Front</label>
          <label class="tag"><input type="radio" name="attachTo" value="back"> Back</label>
          <button id="snapshotBtn" class="ghost">Insert canvas snapshot</button>
          <button id="clearImgsBtn" class="ghost">Remove all images</button>
        </div>
        <div class="muted" style="margin-top:6px">Use the canvas on the right to sketch; click “Insert canvas snapshot” to embed it into the selected side.</div>
      </div>

      <div class="section row">
        <button id="saveBtn" class="primary">Save card (JSON)</button>
        <button id="downloadPNG" class="ghost">Download preview as PNG</button>
        <button id="clearTextBtn" class="ghost" style="color:var(--warn); border-color:var(--warn)">Clear text</button>
      </div>
    </aside>

    <!-- RIGHT: Canvas (Apple Pencil–fixed) -->
    <section class="canvasPane">
      <div class="toolbar">
        <div class="group">
          <button id="penBtn" class="active" title="Pen (P)">Pen</button>
          <button id="eraserBtn" title="Eraser (E)">Eraser</button>
        </div>
        <div class="group">
          <label for="size">Size</label>
          <input id="size" type="range" min="0.5" max="6" step="0.1" value="1.3">
          <span id="sizeVal">1.3</span> px
        </div>
        <div class="group">
          <label for="grid">Grid</label>
          <input id="grid" type="range" min="10" max="40" step="2" value="24">
          <span id="gridVal">24</span> px
          <button id="toggleGrid">Toggle grid</button>
        </div>
        <div class="group">
          <button id="undoBtn" title="Undo (Ctrl/Cmd+Z)">Undo</button>
          <button id="redoBtn" title="Redo (Ctrl/Cmd+Shift+Z)">Redo</button>
          <button id="clearBtn">Clear</button>
          <button id="exportCanvasBtn">Export PNG</button>
        </div>
        <div class="spacer"></div>
      </div>

      <div class="pad" id="pad">
        <canvas id="gridCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
      </div>
    </section>
  </div>

  <script>
    // ======== Left side: LaTeX rendering + snapshot embedding ========
    const frontInput = document.getElementById('frontInput');
    const backInput  = document.getElementById('backInput');
    const frontPreview = document.getElementById('frontPreview');
    const backPreview  = document.getElementById('backPreview');
    const titleInput = document.getElementById('title');

    function render(targetEl, text){
      // basic newline handling + unsafe HTML neutralized
      const safe = text
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/\\n/g,'\n');
      targetEl.innerHTML = safe.replace(/\n/g,'<br/>');
      if (window.MathJax && window.MathJax.typesetPromise) {
        MathJax.typesetPromise([targetEl]).catch(()=>{});
      }
    }
    function refresh(){
      render(frontPreview, frontInput.value);
      render(backPreview, backInput.value);
    }
    frontInput.addEventListener('input', refresh);
    backInput.addEventListener('input', refresh);
    window.addEventListener('load', refresh);

    // Insert canvas snapshot into selected side
    function selectedSide(){ return (document.querySelector('input[name="attachTo"]:checked')||{}).value || 'front'; }

    document.getElementById('snapshotBtn').addEventListener('click', ()=>{
      const dataURL = exportMergedCanvas(); // defined in canvas section
      const img = new Image(); img.src = dataURL; img.style.maxWidth = '100%'; img.style.marginTop = '8px';
      if (selectedSide()==='front') frontPreview.appendChild(img);
      else backPreview.appendChild(img);
    });

    document.getElementById('clearImgsBtn').addEventListener('click', ()=>{
      for (const el of [frontPreview, backPreview]) {
        [...el.querySelectorAll('img')].forEach(n=>n.remove());
      }
    });

    // Save card JSON (front/back HTML after render text + inline images references)
    document.getElementById('saveBtn').addEventListener('click', ()=>{
      const card = {
        title: titleInput.value.trim(),
        front: frontPreview.innerHTML,
        back: backPreview.innerHTML,
        createdAt: new Date().toISOString()
      };
      const blob = new Blob([JSON.stringify(card, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.download = (card.title ? card.title.replace(/[^\w\-]+/g,'_') : 'flashcard') + '.json';
      a.href = URL.createObjectURL(blob);
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // Download rendered preview (front+back concatenated) as PNG
    document.getElementById('downloadPNG').addEventListener('click', async ()=>{
      // Simple: make a canvas and draw each preview as SVG via foreignObject (broadly supported on desktop)
      const container = document.createElement('div');
      container.style.width = '800px';
      container.style.padding = '20px';
      container.style.fontFamily = 'system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif';
      container.innerHTML = '<h3>'+ (titleInput.value||'Flashcard') +'</h3>'
          + '<h4>Front</h4>' + frontPreview.outerHTML
          + '<h4>Back</h4>' + backPreview.outerHTML;

      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="800" height="1000">
        <foreignObject width="100%" height="100%">
          ${new XMLSerializer().serializeToString(container)}
        </foreignObject>
      </svg>`;
      const blob = new Blob([svg], {type:'image/svg+xml'});
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        const c = document.createElement('canvas');
        c.width = 800; c.height = 1000;
        const cx = c.getContext('2d');
        cx.fillStyle = '#ffffff'; cx.fillRect(0,0,800,1000);
        cx.drawImage(img,0,0);
        URL.revokeObjectURL(url);
        const a = document.createElement('a');
        a.download = (titleInput.value||'flashcard')+'.png';
        a.href = c.toDataURL('image/png');
        a.click();
      };
      img.src = url;
    });

    document.getElementById('clearTextBtn').addEventListener('click', ()=>{
      frontInput.value = ''; backInput.value = ''; refresh();
    });

    // ======== Right side: Canvas (Apple Pencil–fixed, grid, undo/redo) ========
    const pad = document.getElementById('pad');
    const gridCanvas = document.getElementById('gridCanvas');
    const drawCanvas = document.getElementById('drawCanvas');
    const gtx = gridCanvas.getContext('2d');
    const ctx = drawCanvas.getContext('2d');

    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const sizeInput = document.getElementById('size');
    const sizeVal = document.getElementById('sizeVal');
    const gridInput = document.getElementById('grid');
    const gridVal = document.getElementById('gridVal');
    const toggleGridBtn = document.getElementById('toggleGrid');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const exportCanvasBtn = document.getElementById('exportCanvasBtn');

    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let mode = 'pen';
    let gridVisible = true;

    let undoStack = [];
    let redoStack = [];

    function setCanvasSize() {
      const rect = pad.getBoundingClientRect();
      dpr = Math.max(1, window.devicePixelRatio || 1);

      for (const c of [gridCanvas, drawCanvas]) {
        c.style.width = rect.width + 'px';
        c.style.height = rect.height + 'px';
        c.width = Math.round(rect.width * dpr);
        c.height = Math.round(rect.height * dpr);
      }
      gtx.setTransform(dpr,0,0,dpr,0,0);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawGrid();
      restoreLatest();
    }

    function drawGrid() {
      gtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
      if (!gridVisible) return;
      const spacing = Number(gridInput.value);
      const rect = pad.getBoundingClientRect();
      const w = rect.width, h = rect.height;

      gtx.save();
      gtx.lineWidth = 1;
      gtx.strokeStyle = '#e3e3e3';
      gtx.beginPath();
      for (let x=0.5; x<=w; x+=spacing) { gtx.moveTo(x,0); gtx.lineTo(x,h); }
      for (let y=0.5; y<=h; y+=spacing) { gtx.moveTo(0,y); gtx.lineTo(w,y); }
      gtx.stroke();
      gtx.restore();
    }

    let isDrawing = false, last=null, pathStarted=false;

    function canvasPointFromEvent(e){
      const r = drawCanvas.getBoundingClientRect();
      return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
    }
    function startStroke(e){
      if (e.button !== undefined && e.button !== 0) return;
      e.preventDefault();
      drawCanvas.setPointerCapture?.(e.pointerId);
      pushUndo();
      isDrawing = true; last = canvasPointFromEvent(e); pathStarted = false; drawPoint(last, e);
    }
    function continueStroke(e){
      if (!isDrawing) return;
      e.preventDefault();
      const p = canvasPointFromEvent(e);
      drawSegment(last, p, e); last = p;
    }
    function endStroke(e){
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false; last=null; pathStarted=false; redoStack.length=0;
    }

    function currentSize(e){
      const base = Number(sizeInput.value);
      const pressure = (e.pressure && e.pressure>0) ? e.pressure : 0.6;
      const penScale = 0.9 + pressure*1.1;
      if (mode==='eraser') return base*3.2;
      return base*penScale;
    }
    function configureCtxForMode(e){
      ctx.lineCap='round'; ctx.lineJoin='round'; ctx.miterLimit=2;
      if (mode==='eraser'){ ctx.globalCompositeOperation='destination-out'; }
      else { ctx.globalCompositeOperation='source-over'; ctx.strokeStyle='#111'; }
      ctx.lineWidth = currentSize(e);
    }
    function drawPoint(p,e){
      configureCtxForMode(e);
      ctx.beginPath(); ctx.arc(p.x,p.y,ctx.lineWidth/2,0,Math.PI*2);
      ctx.fillStyle = (mode==='eraser') ? 'rgba(0,0,0,1)' : '#111';
      ctx.fill(); pathStarted=true;
    }
    function drawSegment(a,b,e){
      configureCtxForMode(e);
      ctx.beginPath();
      const midX=(a.x+b.x)/2, midY=(a.y+b.y)/2;
      if (!pathStarted){ ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); pathStarted=true; }
      else { ctx.moveTo(a.x,a.y); ctx.quadraticCurveTo(a.x,a.y,midX,midY); }
      ctx.stroke();
    }

    function pushUndo(){
      try{
        const img = ctx.getImageData(0,0,drawCanvas.width,drawCanvas.height);
        undoStack.push(img); if (undoStack.length>40) undoStack.shift();
      }catch{}
    }
    function restoreLatest(){
      if (!undoStack.length){ ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); return; }
      try{
        const last = undoStack[undoStack.length-1];
        if (last.width===drawCanvas.width && last.height===drawCanvas.height){
          ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
          ctx.putImageData(last,0,0);
        } else { undoStack.length=0; }
      }catch{}
    }
    function doUndo(){
      if (!undoStack.length) return;
      try{
        const cur = ctx.getImageData(0,0,drawCanvas.width,drawCanvas.height);
        redoStack.push(cur);
        const prev = undoStack.pop();
        ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
        if (prev) ctx.putImageData(prev,0,0);
      }catch{}
    }
    function doRedo(){
      if (!redoStack.length) return;
      try{
        const cur = ctx.getImageData(0,0,drawCanvas.width,drawCanvas.height);
        undoStack.push(cur);
        const next = redoStack.pop();
        ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
        if (next) ctx.putImageData(next,0,0);
      }catch{}
    }

    // Export helpers
    function exportMergedCanvas(){
      const rect = pad.getBoundingClientRect();
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = Math.round(rect.width * dpr);
      exportCanvas.height = Math.round(rect.height * dpr);
      const ex = exportCanvas.getContext('2d');
      ex.setTransform(dpr,0,0,dpr,0,0);
      if (gridVisible) ex.drawImage(gridCanvas,0,0,exportCanvas.width,exportCanvas.height);
      ex.drawImage(drawCanvas,0,0,exportCanvas.width,exportCanvas.height);
      return exportCanvas.toDataURL('image/png');
    }
    document.getElementById('exportCanvasBtn').addEventListener('click', ()=>{
      const link = document.createElement('a');
      link.download = 'canvas.png';
      link.href = exportMergedCanvas();
      link.click();
    });

    // UI wiring
    function setMode(m){ mode=m; penBtn.classList.toggle('active',m==='pen'); eraserBtn.classList.toggle('active',m==='eraser'); }
    penBtn.addEventListener('click', ()=>setMode('pen'));
    eraserBtn.addEventListener('click', ()=>setMode('eraser'));
    sizeInput.addEventListener('input', ()=> sizeVal.textContent = sizeInput.value);
    gridInput.addEventListener('input', ()=>{ gridVal.textContent = gridInput.value; drawGrid(); });
    toggleGridBtn.addEventListener('click', ()=>{ gridVisible=!gridVisible; drawGrid(); });
    undoBtn.addEventListener('click', doUndo);
    redoBtn.addEventListener('click', doRedo);
    clearBtn.addEventListener('click', ()=>{ pushUndo(); ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); redoStack.length=0; });

    window.addEventListener('keydown', (e)=>{
      if (e.key==='p' || e.key==='P') setMode('pen');
      if (e.key==='e' || e.key==='E') setMode('eraser');
      if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z' && !e.shiftKey){ e.preventDefault(); doUndo(); }
      if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z' && e.shiftKey){ e.preventDefault(); doRedo(); }
    });

    drawCanvas.addEventListener('pointerdown', startStroke, {passive:false});
    drawCanvas.addEventListener('pointermove', continueStroke, {passive:false});
    window.addEventListener('pointerup', endStroke, {passive:false});
    window.addEventListener('pointercancel', endStroke, {passive:false});
    window.addEventListener('blur', endStroke);

    const ro = new ResizeObserver(setCanvasSize);
    ro.observe(pad);
    window.addEventListener('orientationchange', setCanvasSize);
    window.addEventListener('load', setCanvasSize);

    sizeVal.textContent = sizeInput.value; gridVal.textContent = gridInput.value;
    setCanvasSize(); pushUndo();

    // Expose for snapshot button
    window.exportMergedCanvas = exportMergedCanvas;
  </script>
</body>
</html>
